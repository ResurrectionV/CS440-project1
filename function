#import
from collections import deque
import random


########################
 #关于check maze的可行性
def check(mz,x1,y1,x2,y2):
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    n,m = len(mz),len(mz[0])
    global path_bfs
    fringe = [] #stores the node that are needed to explore
    fringe.append((x1,y1))
    mz[x1][y1] = 2
    
    while len(fringe) > 0:
        cur = fringe[0]
        
        if cur[0] == x2 and cur[1] == y2:
            return True
        
        for di in dirs:
            next = di(cur[0],cur[1])
            if next[0] < 0 or next[1] < 0 or next[0] > n-1 or next[1] > m - 1:
                continue
            if mz[next[0]][next[1]] == 0:
                fringe.append(next)
                mz[next[0]][next[1]] = 2
            
        fringe = deque(fringe)
        fringe.popleft()
        fringe = list(fringe)
    return False

def back(mz):
    l = len(mz)
    for i in range(l):
        for j in range(l):
            if mz[i][j] == 2:
                mz[i][j] = 0
    return mz

def acessibility(mz):
    #check (unblock center and corner)center to 4 corner and upper left to bottom left(block center)
    #find the center
    l = len(mz)
    c = (l + 1)/2 - 1
    c = int(c)
    #unblock center and corners
    tl = mz[0][0]
    tr = mz[0][l-1]
    bl = mz[l-1][0]
    br = mz[l-1][l-1]
    mid = mz[c][c]
    mz[0][0] = 0
    mz[0][l-1] = 0
    mz[l-1][0] = 0
    mz[l-1][l-1] = 0
    mz[c][c] = 0
    c1 = check(mz,c,c,0,0)
    mz = back(mz)
    c2 = check(mz,c,c,0,l-1)
    mz = back(mz)
    c3 = check(mz,c,c,l-1,0)
    mz = back(mz)
    c4 = check(mz,c,c,l-1,l-1)
    mz = back(mz)
    mz[c][c] = 1
    c5 = check(mz,0,0,l-1,l-1)
    mz = back(mz)
    if not (c1 and c2 and c3 and c4):
        mz[0][0] = tl 
        mz[0][l-1] = tr
        mz[l-1][0] = bl
        mz[l-1][l-1] = br
        mz[c][c] = mid
        return False
    #block the center
    
    if not c5:
        mz[0][0] = tl 
        mz[0][l-1] = tr
        mz[l-1][0] = bl
        mz[l-1][l-1] = br
        mz[c][c] = mid
        return False
    mz[0][0] = tl 
    mz[0][l-1] = tr
    mz[l-1][0] = bl
    mz[l-1][l-1] = br
    mz[c][c] = mid
    return True

#######################
#generate an acessible maze
def genratemaze(num):
    maze=[[0 for i in range(cols)] for i in range(rows)]
    for i in range(num):
        for j in range(num):
            if random.uniform(0,1) > 0.3:
                maze[i][j] = 0 #0 for unblock
            else:
                maze[i][j] = 1 #1 for wall
    if not acessibility(maze):
        maze = generatemaze(num)
    return maze



###############################

#Each time agent moves one step, we implement this function for attaining a new probability matrix that stores the probability of catching a fire for each entry.
def Fire(q,maze):
    row = len(maze)
    col = len(maze[0])
    fm = [[0]*row for _ in range(col)]
    for i in range(row):
        for j in range(col):
            count = 0;
            for di in dircs:
                cur = di[i,j]
                if cur[0] < 0 or cur[0] > row-1 or cur[1] < 0 or cur[1] > col -1:
                    continue
                if maze[i][j] == 3:
                    count++
            fm[i][j] = 1 - (1 - q)**count
    return fm


path_dfs = []
def dfs(mz,x1,y1,x2,y2): #start at (x1,y1), end at (x2,y2)
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    global path_dfs
    l = len(mz)
    
    fringe = [(x1,x2)]
    path_dfs.append(fringe[0])
    while not fringe == []:
        cur = fringe[-1]
        fringe.pop
        if cur == (x2,y2):
            return True
        for di in dirs:
            next = di(cur[0],cur[1])
            if -1<next[0]<l and -1<next[1]<l:
                if mz[next[0]][next[1]] == 0:
                    fringe.append(next)
                    mz[next[0]][next[1]] == 1
                continue
            else:
                continue     
    return False
        
        

path_bfs = []
def bfs(mz,x1,y1,x2,y2):
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    
    n,m = len(mz),len(mz[0])
    global path_bfs
    fringe = [] #stores the node that are needed to explore
    fringe.append((x1,y1))
    mz[x1][y1] = 1
    path_bfs.append(fringe[0])
    
    while len(fringe) > 0:
        cur = fringe[0]
        
        if cur[0] == x2 and cur[1] == y2:
            temp_path = []
            temp_path.append(path_bfs[-1])
            temp_Node = path_bfs[-1]
            path_bfs.pop()
            
            while (not temp_Node[0] == x1) and (not temp_Node[1] == y1):
                for di in dirs:
                    node = di(temp_Node[0],temp_Node[1])
                    count = 0
                    for n in path_bfs:
                        if node[0] == n[0] and node[1] == n[1]:
                            temp_path.append(node)
                            path_bfs.pop(count)
                        count = count + 1
            path_bfs = temp_path.reverse()
            return True
        
        for di in dirs:
            next = di(cur[0],cur[1])
            if mz[cur[0]][cur[1]] == 0:
                path_bfs.append(next)
                mz[cur[0]][cur[1]] = 1
    return False
    
   
