#Each time agent moves one step, we implement this function for attaining a new probability matrix that stores the probability of catching a fire for each entry.
def Fire(q,maze):
    row = len(maze)
    col = len(maze[0])
    fm = [[0]*row for _ in range(col)]
    for i in range(row):
        for j in range(col):
            count = 0;
            for di in dircs:
                cur = di[i,j]
                if cur[0] < 0 or cur[0] > row-1 or cur[1] < 0 or cur[1] > col -1:
                    continue
                if maze[i][j] == 3:
                    count++
            fm[i][j] = 1 - (1 - q)**count
    return fm


path_dfs = []
def dfs(mz,x1,y1,x2,y2): #start at (x1,y1), end at (x2,y2)
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    global path_dfs
    
    if x1 == x2 and y1 == y2:
        return True
    
    for di in dirs:
        cur = di(x1,y1)
        if cur[0] > len(mz) - 2 or cur[1] > len(mz) - 2 or cur[0] < 0 or cur[1] < 0:
            continue
        direction = ''
        if cur[0] - x1 == 1:
            direction = 'D' #Downward
        if cur[0] - x1 == -1:
            direction = 'U' #Upward
        if cur[1] - y1 == 1:
            direction = 'R' #Rightward
        if cur[0] - y1 == -1:
            direction = 'L' #Leftward
        mz[cur[0]][cur[1]] = 1 #maze 1 for wall and 0 for acessible
        path_dfs.append(direction)
        dfs(mz,cur[0], cur[1], x2, y2)
        path = path_dfs[:-1]
        maze[cur[0]][cur[1]] = 0
    return False
        
        

path_bfs = []
def bfs(mz,x1,y1,x2,y2):
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    
    n,m = len(mz),len(mz[0])
    global path_bfs
    fringe = [] #stores the node that are needed to explore
    fringe.append((x1,y1))
    mz[x1][y1] = 1
    path_bfs.append(fringe[0])
    
    while len(fringe) > 0:
        cur = fringe[0]
        
        if cur[0] == x2 and cur[1] == y2:
            temp_path = []
            temp_path.append(path_bfs[-1])
            temp_Node = path_bfs[-1]
            path_bfs.pop()
            
            while (not temp_Node[0] == x1) and (not temp_Node[1] == y1):
                for di in dirs:
                    node = di(temp_Node[0],temp_Node[1])
                    count = 0
                    for n in path_bfs:
                        if node[0] == n[0] and node[1] == n[1]:
                            temp_path.append(node)
                            path_bfs.pop(count)
                        count = count + 1
            path_bfs = temp_path.reverse()
            return True
        
        for di in dirs:
            next = di(cur[0],cur[1])
            if mz[cur[0]][cur[1]] == 0:
                path_bfs.append(next)
                mz[cur[0]][cur[1]] = 1
    return False
    
    关于check maze的可行性
    #######################################
def check(mz,x1,y1,x2,y2):
    dirs = [
        lambda x,y: ( x+1 , y ),
        lambda x,y: ( x-1 , y ),
        lambda x,y: ( x , y+1 ),
        lambda x,y: ( x , y-1 )
        ]
    n,m = len(mz),len(mz[0])
    global path_bfs
    fringe = [] #stores the node that are needed to explore
    fringe.append((x1,y1))
    mz[x1][y1] = 2
    
    while len(fringe) > 0:
        cur = fringe[0]
        
        if cur[0] == x2 and cur[1] == y2:
            return True
        
        for di in dirs:
            next = di(cur[0],cur[1])
            if next[0] < 0 or next[1] < 0 or next[0] > n-1 or next[1] > m - 1:
                continue
            if mz[next[0]][next[1]] == 0:
                fringe.append(next)
                mz[next[0]][next[1]] = 2
            
        fringe = deque(fringe)
        fringe.popleft()
        fringe = list(fringe)
    return False

def acessibility(mz):
    #check (unblock center and corner)center to 4 corner and upper left to bottom left(block center)
    #find the center
    l = len(mz)
    c = (l + 1)/2 - 1
    c = int(c)
    #unblock center and corners
    mz[0][0] = 0
    mz[0][l-1] = 0
    mz[l-1][0] = 0
    mz[l-1][l-1] = 0
    mz[c][c] = 0
    mz1 = mz
    mz2 = mz
    mz3 = mz
    mz4 = mz
    mz5 = mz
    if not (check(mz1,c,c,0,0) and check(mz2,c,c,0,l-1) and check(mz3,c,c,l-1,0) and check(mz4,c,c,l-1,l-1)):
        return False
    #block the center
    mz5[c][c] = 1
    if not check(mz5,0,0,l-1,l-1):
        return False
    return True
